<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>4x4 Custom Chess Game - Double Layer Fixed Star</title>
    
    <style>
        /* 1. ‡§®‡•â‡§®-‡§ú‡§º‡•Ç‡§Æ‡•á‡§¨‡§≤ ‡§î‡§∞ ‡§®‡•â‡§®-‡§∏‡•ç‡§ï‡•ç‡§∞‡•â‡§≤‡•á‡§¨‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è CSS */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            height: 100%;
            width: 100%;
        }

        /* 2. ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§™‡§æ‡§∞‡§¶‡§∞‡•ç‡§∂‡•Ä ‡§¨‡•à‡§ï‡§ó‡•ç‡§∞‡§æ‡§â‡§Ç‡§° */
        body {
            background-color: transparent !important; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 3. 1:1 ‡§ï‡§Ç‡§ü‡•á‡§®‡§∞ */
        #game-container {
            width: 100vw; 
            height: 100vw; 
            max-width: 100vh; 
            max-height: 100vh;
            box-sizing: border-box;
            padding: 1vmin; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100%;
            flex: 1; 
            border: none;
        }

        .square {
            background-color: transparent !important; 
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-sizing: border-box;
            border: 1px solid rgba(0, 0, 0, 0.1); 
            position: relative; 
            overflow: hidden; /* ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç ‡§ï‡§ø ‡§á‡§Æ‡•á‡§ú ‡§∏‡•á‡§≤ ‡§ï‡•á ‡§¨‡§æ‡§π‡§∞ ‡§® ‡§ú‡§æ‡§è */
        }

        /* ‡§á‡§Æ‡•á‡§ú ‡§∏‡•ç‡§ü‡§æ‡§á‡§≤ */
        .piece-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            position: absolute; 
        }

        /* ‡§¨‡•á‡§∏ ‡§á‡§Æ‡•á‡§ú (Star/Block/Empty) - ‡§™‡•Ä‡§õ‡•á ‡§∞‡§π‡•á‡§ó‡•Ä */
        .base-image {
            z-index: 1; 
            /* Base ‡§á‡§Æ‡•á‡§ú ‡§ï‡•ã ‡§•‡•ã‡§°‡§º‡§æ ‡§õ‡•ã‡§ü‡§æ ‡§∞‡§ñ‡•á‡§Ç ‡§§‡§æ‡§ï‡§ø ‡§ï‡§∞‡§Ç‡§ü ‡§á‡§Æ‡•á‡§ú ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡§ó‡§π ‡§¨‡§®‡•á */
            width: 100%; 
            height: 100%;
        }

        /* ‡§ï‡§∞‡§Ç‡§ü ‡§á‡§Æ‡•á‡§ú (King/Rook/Empty) - ‡§Ü‡§ó‡•á ‡§∞‡§π‡•á‡§ó‡•Ä */
        .current-image {
            z-index: 2; 
            transition: transform 0.1s ease-in-out;
        }

        /* ‡§ú‡§¨ ‡§ï‡•ã‡§à ‡§Æ‡•Ç‡§µ‡•á‡§¨‡§≤ ‡§ü‡•ã‡§ï‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§§‡§æ ‡§π‡•à, ‡§§‡§¨ ‡§ï‡§∞‡§Ç‡§ü ‡§á‡§Æ‡•á‡§ú ‡§ï‡•ã ‡§õ‡§ø‡§™‡§æ‡§è‡§Å (Transparent ‡§∞‡§ñ‡•á‡§Ç) */
        /* ‡§Ø‡§π ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§¨‡•á‡§∏ ‡§á‡§Æ‡•á‡§ú (Star) ‡§π‡§Æ‡•á‡§∂‡§æ ‡§¶‡§ø‡§ñ‡•á */
        .current-image[alt="Empty_Current"] {
            display: none; 
        }


        .selected {
            background-color: rgba(255, 235, 59, 0.5) !important; 
        }

        .highlight {
            background-color: rgba(165, 214, 167, 0.5) !important; 
        }
        
        #status-message {
            width: 100%;
            text-align: center;
            margin-top: 1vmin;
            font-size: 3vmin;
            font-weight: bold;
            color: #333;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="board">
            </div>
        <div id="status-message">Loading game...</div>
    </div>

    <script>
        /* JavaScript (‡§´‡§ø‡§ï‡•ç‡§∏‡•ç‡§° Star/Empty ‡§≤‡•â‡§ú‡§ø‡§ï) */
        
        // !!! ‡§Ø‡§π‡§æ‡§Å ‡§Ö‡§™‡§®‡•Ä GitHub ‡§∞‡•â JSON ‡§≤‡§ø‡§Ç‡§ï ‡§°‡§æ‡§≤‡•á‡§Ç !!!
        const JSON_URL = "https://raw.githubusercontent.com/GOLu496/Files/main/puzzle.json";

        const IMAGE_FILES = {
            'Rook': 'rook.png',
            'Knight': 'knight.png',
            'Bishop': 'bishop.png',
            'King': 'king.png',
            'Star': 'star.png', 
            'Block': 'block.jpg',
            'Empty_Base': 'empty.png', 
            'Empty_Current': 'empty.png' 
        };
        
        const FIXED_TOKENS = ['Star', 'Block'];

        const BOARD_SIZE = 4;
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status-message');

        // boardState ‡§Ö‡§¨ ‡§è‡§ï ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§ï‡§∞‡•á‡§ó‡§æ: {base: 'Star' / 'Empty_Base', current: 'King' / null}
        let boardState = []; 
        let selectedSquare = null; 
        let isGameOver = false;

        // --- 1. JSON ‡§°‡•á‡§ü‡§æ ‡§è‡§ï‡•ç‡§∏‡§ü‡•ç‡§∞‡•à‡§ï‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§ó‡•á‡§Æ ‡§ï‡•ã ‡§á‡§®‡§ø‡§∂‡§ø‡§Ø‡§≤‡§æ‡§á‡•õ ‡§ï‡§∞‡•á‡§Ç ---
        async function loadGame() {
            try {
                statusElement.textContent = "Fetching game data...";
                const response = await fetch(JSON_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const initialConfig = await response.json();
                
                // ‡§¨‡•ã‡§∞‡•ç‡§° ‡§ï‡•ã ‡§á‡§®‡§ø‡§∂‡§ø‡§Ø‡§≤‡§æ‡§á‡•õ ‡§ï‡§∞‡•á‡§Ç: {base: 'Empty_Base', current: null}
                boardState = Array(BOARD_SIZE).fill(0).map(() => 
                    Array(BOARD_SIZE).fill(0).map(() => ({ base: 'Empty_Base', current: null }))
                );

                initialConfig.pieces.forEach(p => {
                    if (p.row >= 0 && p.row < BOARD_SIZE && p.col >= 0 && p.col < BOARD_SIZE && IMAGE_FILES[p.piece]) {
                        const cell = boardState[p.row][p.col];
                        
                        if (FIXED_TOKENS.includes(p.piece)) {
                            // Star ‡§Ø‡§æ Block ‡§ï‡•ã base ‡§≤‡•á‡§Ø‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
                            cell.base = p.piece;
                        } else {
                            // Movable ‡§ü‡•ã‡§ï‡§® ‡§ï‡•ã current ‡§≤‡•á‡§Ø‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç
                            cell.current = p.piece;
                        }
                    }
                });

                isGameOver = false;
                renderBoard();
                statusElement.textContent = "Game started! Move the King to the Star to win.";

            } catch (error) {
                console.error("Failed to load game configuration:", error);
                statusElement.textContent = `Error loading game. Check your JSON_URL and internet connection.`;
            }
        }

        // --- 2. ‡§¨‡•ã‡§∞‡•ç‡§° ‡§ï‡•ã HTML ‡§™‡§∞ ‡§∞‡•á‡§Ç‡§°‡§∞ ‡§ï‡§∞‡•á‡§Ç (‡§´‡§ø‡§ï‡•ç‡§∏‡•ç‡§° Star ‡§ï‡•á ‡§∏‡§æ‡§•) ---
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cellData = boardState[r][c];
                    
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.setAttribute('data-row', r);
                    square.setAttribute('data-col', c);
                    square.addEventListener('click', () => handleSquareClick(r, c));

                    // ‡§¨‡•á‡§∏ ‡§á‡§Æ‡•á‡§ú (Star, Block, ‡§Ø‡§æ Empty_Base) - ‡§Ø‡§π ‡§π‡§Æ‡•á‡§∂‡§æ ‡§¶‡§ø‡§ñ‡•á‡§ó‡•Ä
                    const baseImage = document.createElement('img');
                    baseImage.classList.add('piece-image', 'base-image');
                    baseImage.src = IMAGE_FILES[cellData.base];
                    baseImage.alt = cellData.base;
                    square.appendChild(baseImage);

                    // ‡§ï‡§∞‡§Ç‡§ü ‡§á‡§Æ‡•á‡§ú (Movable Piece, ‡§Ø‡§æ Empty_Current)
                    const currentPiece = cellData.current || 'Empty_Current';
                    const currentImage = document.createElement('img');
                    currentImage.classList.add('piece-image', 'current-image');
                    currentImage.src = IMAGE_FILES[currentPiece];
                    currentImage.alt = currentPiece;
                    square.appendChild(currentImage);

                    boardElement.appendChild(square);
                }
            }
            
            // ‡§π‡§æ‡§à‡§≤‡§æ‡§á‡§ü‡•ç‡§∏ (‡§™‡•Å‡§∞‡§æ‡§®‡•á ‡§≤‡•â‡§ú‡§ø‡§ï ‡§ï‡•Ä ‡§§‡§∞‡§π)
            if (selectedSquare) {
                const [sR, sC] = selectedSquare;
                const selectedElement = boardElement.querySelector(`[data-row="${sR}"][data-col="${sC}"]`);
                if (selectedElement) selectedElement.classList.add('selected');
                
                const selectedPieceType = boardState[sR][sC].current;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (isValidMove(selectedPieceType, sR, sC, r, c)) {
                            const targetElement = boardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (targetElement) targetElement.classList.add('highlight');
                        }
                    }
                }
            }
        }

        // --- 3. ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§á‡§µ‡•á‡§Ç‡§ü ‡§π‡•à‡§Ç‡§°‡§≤ ‡§ï‡§∞‡•á‡§Ç ---
        function handleSquareClick(row, col) {
            if (isGameOver) {
                statusElement.textContent = "Game Over! Refresh to play again.";
                return;
            }
            
            const cellData = boardState[row][col];
            const pieceType = cellData.current;
            
            if (selectedSquare) {
                const [sR, sC] = selectedSquare;
                const selectedPieceType = boardState[sR][sC].current;
                
                if (isValidMove(selectedPieceType, sR, sC, row, col)) {
                    
                    // 3a. ‡§µ‡§ø‡§® ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§® ‡§ö‡•á‡§ï ‡§ï‡§∞‡•á‡§Ç
                    if (cellData.base === 'Star' && selectedPieceType === 'King') {
                        isGameOver = true;
                        
                        boardState[row][col].current = selectedPieceType; 
                        boardState[sR][sC].current = null; 
                        
                        selectedSquare = null;
                        renderBoard();
                        statusElement.textContent = "üèÜ CONGRATULATIONS! King reached the Star! üèÜ";
                        return; 
                    }

                    // 3b. ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§ö‡§æ‡§≤
                    
                    // ‡§®‡§Ø‡§æ ‡§∏‡•á‡§≤: ‡§ä‡§™‡§∞ ‡§ï‡§æ ‡§ü‡•ã‡§ï‡§® ‡§≤‡•á ‡§ú‡§æ‡§è‡§Å
                    boardState[row][col].current = selectedPieceType;
                    
                    // ‡§™‡•Å‡§∞‡§æ‡§®‡§æ ‡§∏‡•á‡§≤: ‡§ä‡§™‡§∞ ‡§ï‡§æ ‡§ü‡•ã‡§ï‡§® ‡§π‡§ü‡§æ‡§è‡§Å
                    boardState[sR][sC].current = null; 
                    
                    selectedSquare = null;
                    renderBoard();
                    statusElement.textContent = `Moved ${selectedPieceType}. Your turn.`;
                } 
                // 3c. ‡§°‡•Ä-‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§Ø‡§æ ‡§®‡§Ø‡§æ ‡§ü‡•ã‡§ï‡§® ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç
                else {
                    selectedSquare = null;
                    if (pieceType && isMovable(pieceType)) {
                        selectPiece(row, col);
                    } else {
                        renderBoard(); 
                    }
                }
            } 
            // 3d. ‡§ü‡•ã‡§ï‡§® ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç 
            else if (pieceType && isMovable(pieceType)) {
                selectPiece(row, col);
            }
        }

        // --- 4. ‡§ü‡•ã‡§ï‡§® ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç ---
        function selectPiece(row, col) {
            selectedSquare = [row, col];
            renderBoard(); 
        }

        // --- 5. ‡§®‡§ø‡§Ø‡§Æ ‡§î‡§∞ ‡§Æ‡•Ç‡§µ ‡§≤‡•â‡§ú‡§ø‡§ï (‡§µ‡§π‡•Ä ‡§∞‡§π‡§æ) ---

        function isMovable(pieceType) {
            // ‡§ï‡•á‡§µ‡§≤ ‡§Æ‡•Ç‡§µ‡•á‡§¨‡§≤ ‡§ü‡•ã‡§ï‡§® ‡§ï‡•ã ‡§π‡•Ä ‡§∏‡•á‡§≤‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•á‡§Ç
            return pieceType !== null && !FIXED_TOKENS.includes(pieceType);
        }

        function isValidMove(pieceType, startR, startC, endR, endC) {
            if (startR === endR && startC === endC) return false;
            
            const targetCell = boardState[endR][endC];
            
            // Rule: Block (base layer) ‡§™‡§∞ ‡§ï‡•ã‡§à ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ
            if (targetCell.base === 'Block') return false;
            
            // Rule: ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§Æ‡•Ç‡§µ‡•á‡§¨‡§≤ ‡§ü‡•ã‡§ï‡§® (current layer) ‡§™‡§∞ ‡§ï‡§¨‡•ç‡§ú‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ (‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§∏‡§≠‡•Ä ‡§è‡§ï ‡§∞‡§Ç‡§ó ‡§ï‡•á ‡§π‡•à‡§Ç)
            if (targetCell.current !== null) return false;


            const dr = Math.abs(endR - startR);
            const dc = Math.abs(endC - startC);

            switch (pieceType) {
                case 'King':
                    return dr <= 1 && dc <= 1;

                case 'Rook':
                    if (dr === 0 || dc === 0) {
                        return !isPathBlocked(startR, startC, endR, endC);
                    }
                    return false;

                case 'Bishop':
                    if (dr === dc) {
                        return !isPathBlocked(startR, startC, endR, endC);
                    }
                    return false;

                case 'Knight':
                    return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                    
                default:
                    return false;
            }
        }

        // ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§Ö‡§µ‡§∞‡•ã‡§ß‡§ï ‡§ï‡•Ä ‡§ú‡§æ‡§Å‡§ö (Rook ‡§î‡§∞ Bishop ‡§ï‡•á ‡§≤‡§ø‡§è)
        function isPathBlocked(startR, startC, endR, endC) {
            const rStep = Math.sign(endR - startR);
            const cStep = Math.sign(endC - startC);
            
            let r = startR + rStep;
            let c = startC + cStep;
            
            while (r !== endR || c !== endC) {
                const cell = boardState[r][c];
                
                // ‡§Ö‡§ó‡§∞ ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç Block ‡§π‡•à, ‡§§‡•ã ‡§∞‡§æ‡§∏‡•ç‡§§‡§æ ‡§¨‡§Ç‡§¶
                if (cell.base === 'Block') return true;
                
                // ‡§Ö‡§ó‡§∞ ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§Æ‡•Ç‡§µ‡•á‡§¨‡§≤ ‡§ü‡•ã‡§ï‡§® ‡§π‡•à, ‡§§‡•ã ‡§∞‡§æ‡§∏‡•ç‡§§‡§æ ‡§¨‡§Ç‡§¶
                if (cell.current !== null) return true;
                
                r += rStep;
                c += cStep;
            }
            return false;
        }

        // ‡§ó‡•á‡§Æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç
        loadGame();
    </script>
</body>
</html>
