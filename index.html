<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>4x4 Custom Chess Game</title>
    
    <style>
        
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            height: 100%;
            width: 100%;
        }

        
        html, body {
            background-color: transparent !important; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        
        #game-container {
            width: 100vw; 
            height: 100vw; 
            max-width: 100vh; 
            max-height: 100vh;
            box-sizing: border-box;
            padding: 0vmin; 
            display: flex;
            flex-direction: column;
            align-items: center;
            
        }

        #board {
            background-image: url('bg.jpg');
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100%;
            flex: 1; 
            border: none;
            
        }

        .square {
            background-color: transparent !important; 
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-sizing: border-box;
            border: none; 
            position: relative; 
            overflow: hidden;
        }

    
        .piece-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            position: absolute; 
        }

        
        .base-image {
            z-index: 1;
            width: 100%; 
            height: 100%;
        }

        
        .current-image {
            z-index: 2; 
            transition: transform 0.1s ease-in-out;
        }

        
        .current-image[alt="Empty_Current"] {
            display: none; 
        }


        .selected {
            background-color: rgba(255, 235, 59, 0.5) !important; 
        }

        .highlight {
            background-color: rgba(165, 214, 167, 0.5) !important; 
        }
        
        
    </style>
</head>
<body>

    <div id="game-container">
        <div id="board">
            </div>
        
    </div>

    <script>
        
        const JSON_URL = "https://raw.githubusercontent.com/GOLu496/Files/main/puzzle.json";

        const IMAGE_FILES = {
            'Rook': 'rook.png',
            'Knight': 'knight.png',
            'Bishop': 'bishop.png',
            'King': 'king.png',
            'Star': 'star.png', 
            'Block': 'block.jpg',
            'Empty_Base': 'empty.png', 
            'Empty_Current': 'empty.png' 
        };
        
        const FIXED_TOKENS = ['Star', 'Block'];

        const BOARD_SIZE = 4;
        const boardElement = document.getElementById('board');
        

        
        let boardState = []; 
        let selectedSquare = null; 
        let isGameOver = false;


        async function loadGame() {
            try {
                
                const response = await fetch(JSON_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const initialConfig = await response.json();
                
                
                boardState = Array(BOARD_SIZE).fill(0).map(() => 
                    Array(BOARD_SIZE).fill(0).map(() => ({ base: 'Empty_Base', current: null }))
                );

                initialConfig.pieces.forEach(p => {
                    if (p.row >= 0 && p.row < BOARD_SIZE && p.col >= 0 && p.col < BOARD_SIZE && IMAGE_FILES[p.piece]) {
                        const cell = boardState[p.row][p.col];
                        
                        if (FIXED_TOKENS.includes(p.piece)) {
                            
                            cell.base = p.piece;
                        } else {
                            
                            cell.current = p.piece;
                        }
                    }
                });

                isGameOver = false;
                renderBoard();
                

            } catch (error) {
                console.error("Failed to load game configuration:", error);
                
            }
        }

    
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cellData = boardState[r][c];
                    
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.setAttribute('data-row', r);
                    square.setAttribute('data-col', c);
                    square.addEventListener('click', () => handleSquareClick(r, c));

                    
                    const baseImage = document.createElement('img');
                    baseImage.classList.add('piece-image', 'base-image');
                    baseImage.src = IMAGE_FILES[cellData.base];
                    baseImage.alt = cellData.base;
                    square.appendChild(baseImage);

                    
                    const currentPiece = cellData.current || 'Empty_Current';
                    const currentImage = document.createElement('img');
                    currentImage.classList.add('piece-image', 'current-image');
                    currentImage.src = IMAGE_FILES[currentPiece];
                    currentImage.alt = currentPiece;
                    square.appendChild(currentImage);

                    boardElement.appendChild(square);
                }
            }
            

            if (selectedSquare) {
                const [sR, sC] = selectedSquare;
                const selectedElement = boardElement.querySelector(`[data-row="${sR}"][data-col="${sC}"]`);
                if (selectedElement) selectedElement.classList.add('selected');
                
                const selectedPieceType = boardState[sR][sC].current;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (isValidMove(selectedPieceType, sR, sC, r, c)) {
                            const targetElement = boardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (targetElement) targetElement.classList.add('highlight');
                        }
                    }
                }
            }
        }

        
        function handleSquareClick(row, col) {
            if (isGameOver) {
                
                return;
            }
            
            const cellData = boardState[row][col];
            const pieceType = cellData.current;
            
            if (selectedSquare) {
                const [sR, sC] = selectedSquare;
                const selectedPieceType = boardState[sR][sC].current;
                
                if (isValidMove(selectedPieceType, sR, sC, row, col)) {
                    
                    
                    if (cellData.base === 'Star' && selectedPieceType === 'King') {
                        isGameOver = true;

                        statusElement.textContent = ' Game_Won';
                        
                        boardState[row][col].current = selectedPieceType; 
                        boardState[sR][sC].current = null; 
                        
                        selectedSquare = null;
                        renderBoard();
                        
                        return; 
                    }

                
                    
                
                    boardState[row][col].current = selectedPieceType;
                    
                
                    boardState[sR][sC].current = null; 
                    
                    selectedSquare = null;
                    renderBoard();
                    
                } 
                
                else {
                    selectedSquare = null;
                    if (pieceType && isMovable(pieceType)) {
                        selectPiece(row, col);
                    } else {
                        renderBoard(); 
                    }
                }
            } 
             
            else if (pieceType && isMovable(pieceType)) {
                selectPiece(row, col);
            }
        }

        
        function selectPiece(row, col) {
            selectedSquare = [row, col];
            renderBoard(); 
        }

        
        function isMovable(pieceType) {
        
            return pieceType !== null && !FIXED_TOKENS.includes(pieceType);
        }

        function isValidMove(pieceType, startR, startC, endR, endC) {
            if (startR === endR && startC === endC) return false;
            
            const targetCell = boardState[endR][endC];
            
        
            if (targetCell.base === 'Block') return false;
            
        
            if (targetCell.current !== null) return false;


            const dr = Math.abs(endR - startR);
            const dc = Math.abs(endC - startC);

            switch (pieceType) {
                case 'King':
                    return dr <= 1 && dc <= 1;

                case 'Rook':
                    if (dr === 0 || dc === 0) {
                        return !isPathBlocked(startR, startC, endR, endC);
                    }
                    return false;

                case 'Bishop':
                    if (dr === dc) {
                        return !isPathBlocked(startR, startC, endR, endC);
                    }
                    return false;

                case 'Knight':
                    return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                    
                default:
                    return false;
            }
        }

                function isPathBlocked(startR, startC, endR, endC) {
            const rStep = Math.sign(endR - startR);
            const cStep = Math.sign(endC - startC);
            
            let r = startR + rStep;
            let c = startC + cStep;
            
            while (r !== endR || c !== endC) {
                const cell = boardState[r][c];
                
                
            if (cell.base === 'Block') return true;
                
            
                if (cell.current !== null) return true;
                
                r += rStep;
                c += cStep;
            }
            return false;
        }
    
    function handleSquareClick(row, col) {
    if (isGameOver) {
        return;
    }
    
    const cellData = boardState[row][col];
    const pieceType = cellData.current;
    
    if (selectedSquare) {
        const [sR, sC] = selectedSquare;
        const selectedPieceType = boardState[sR][sC].current;
        
        if (isValidMove(selectedPieceType, sR, sC, row, col)) {
            
            if (cellData.base === 'Star' && selectedPieceType === 'King') {
                isGameOver = true;

               
                sendToKodular("win");
                
                
                boardState[row][col].current = selectedPieceType; 
                boardState[sR][sC].current = null; 
                
                selectedSquare = null;
                renderBoard();

                
                document.getElementById('board').style.display = 'none';
                const winMessage = document.createElement('div');
                winMessage.style.fontSize = '3em';
                winMessage.style.color = 'Black';
                winMessage.style.textAlign = 'center';
                winMessage.style.marginTop = '20px';
                winMessage.textContent = 'You won!';
                document.getElementById('game-container').appendChild(winMessage);
                
                return; 
            }

           
            boardState[row][col].current = selectedPieceType;
            boardState[sR][sC].current = null;
            
            
            sendToKodular("-1");
            
            selectedSquare = null;
            renderBoard();
            
        } else {
            selectedSquare = null;
            if (pieceType && isMovable(pieceType)) {
                selectPiece(row, col);
            } else {
                renderBoard(); 
            }
        }
    } else if (pieceType && isMovable(pieceType)) {
        selectPiece(row, col);
    }
}

function sendToKodular(message) {
      
    if(window.KodularWebViewerGoBack) {
        window.KodularWebViewerGoBack(message);
    } else if(window.postMessage) {
        
        window.postMessage(message, "*");
    } else {
        console.log("Message to Kodular: " + message);
    }
}

        function isInKodularWebViewer() {
    const ua = navigator.userAgent || "";
    if (ua.includes("AndroidWebView") || ua.includes("Kodular")) return true;
    if (window.KodularWebViewerGoBack) return true;
    return false;
}

if (!isInKodularWebViewer()) {
    document.body.innerHTML = `
      <div id="loading-screen" style="height:100vh; display:flex; justify-content:center; align-items:center; flex-direction:column; font-size:1.8rem; color:#444;">
        Please wait... Loading game<span id="dots">.</span>
        <div style="margin: 20px 0; width: 80%; height: 20px; border: 2px solid #3498db; border-radius: 10px; overflow: hidden;">
          <div id="progress-bar" style="width: 0%; height: 100%; background-color: #3498db; border-radius: 10px;"></div>
        </div>
        <div id="progress-text">0%</div>
      </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg);}
        100% { transform: rotate(360deg);}
      }
    `;
    document.head.appendChild(style);

    let dotCount = 1;
    setInterval(() => {
        const dots = document.getElementById('dots');
        if (dots) {
            dotCount = (dotCount % 3) + 1;
            dots.textContent = '.'.repeat(dotCount);
        }
    }, 500);

    let progress = 0;
    const interval = setInterval(() => {
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        if (progressBar && progressText) {
            if (progress >= 100) {
                clearInterval(interval);
            } else {
                progress++;
                progressBar.style.width = progress + '%';
                progressText.textContent = progress + '%';
            }
        }
    }, 100);

} else {
    loadGame();
}
    </script>
</body>
</html>
