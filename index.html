<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>4x4 Chess Game</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100vh; background: transparent;
    display: flex; justify-content: center; align-items: center;
  }
  #board {
    width: 320px;
    height: 320px;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 0;
    background: transparent;
    user-select: none;
    position: relative;
  }
  .cell {
    border: none;
    background: transparent;
    width: 100%;
    height: 100%;
    position: relative;
    transition: background-color 0.3s ease;
  }
  .cell.selected {
    background-color: yellow;
  }
  .cell.possible-move {
    background-color: blue;
  }
  .token {
    position: absolute;
    width: 80%;
    height: 80%;
    top: 10%;
    left: 10%;
    cursor: pointer;
    z-index: 2;
  }
  .token.fixed {
    cursor: default;
  }
</style>
</head>
<body>
<div id="board"></div>
<script>
  const TOKEN_IMAGES = {
    rook: 'rook.png',
    bishop: 'bishop.png',
    knight: 'knight.png',
    king: 'king.png',
    star: 'star.png',
    block: 'block.jpg'
  };
  const GITHUB_RAW_JSON_URL = 'https://raw.githubusercontent.com/GOLu496/Files/main/puzzle.json';

  const rows = ['A', 'B', 'C', 'D'];
  const cols = ['1', '2', '3', '4'];
  let boardState = {};
  let fixedTokens = new Set();
  let selectedToken = null;
  let selectedPos = null;

  function createBoard() {
    const board = document.getElementById('board');
    board.innerHTML = '';
    for (let r of rows) {
      for (let c of cols) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.pos = r + c;
        board.appendChild(cell);
      }
    }
  }

  async function loadBoardData() {
    try {
      const res = await fetch(GITHUB_RAW_JSON_URL);
      if (!res.ok) throw new Error('Failed to fetch');
      const data = await res.json();
      setBoardState(data);
    } catch(e) {
      console.error('Load error:', e);
    }
  }

  function setBoardState(data) {
    boardState = {};
    fixedTokens.clear();
    document.querySelectorAll('.token').forEach(t => t.remove());
    for (let pos in data) {
      let token = data[pos];
      boardState[pos] = token;
      if(token === 'star' || token === 'block') fixedTokens.add(pos);
    }
    renderTokens();
  }

  function renderTokens() {
    // Clear all tokens and remove cell highlights
    document.querySelectorAll('.token').forEach(t => t.remove());
    document.querySelectorAll('.cell').forEach(cell => {
      cell.classList.remove('selected', 'possible-move');
      cell.onclick = null;
    });

    for(let pos in boardState) {
      let token = boardState[pos];
      const cell = document.querySelector(`.cell[data-pos="${pos}"]`);
      let img = document.createElement('img');
      img.src = TOKEN_IMAGES[token] || 'unknown.png';
      img.className = 'token';
      if(fixedTokens.has(pos)) img.classList.add('fixed');
      img.dataset.pos = pos;
      img.dataset.token = token;
      cell.appendChild(img);

      if(!fixedTokens.has(pos)) {
        img.addEventListener('click', () => selectToken(img));
      }
    }
  }

  function selectToken(tokenElem) {
    clearHighlights();
    // Deselect previous if any
    if(selectedToken) {
      const prevCell = document.querySelector(`.cell[data-pos="${selectedPos}"]`);
      if(prevCell) prevCell.classList.remove('selected');
      selectedToken.style.border = '';
    }
    selectedToken = tokenElem;
    selectedPos = tokenElem.dataset.pos;

    // Highlight selected token's cell yellow
    const cell = document.querySelector(`.cell[data-pos="${selectedPos}"]`);
    if(cell) cell.classList.add('selected');

    // Optional border highlight on token
    selectedToken.style.border = '2px solid white';

    // Show possible moves with blue background
    const moves = calculateMoves(selectedPos, selectedToken.dataset.token);
    moves.forEach(p => {
      let moveCell = document.querySelector(`.cell[data-pos="${p}"]`);
      if(moveCell) {
        moveCell.classList.add('possible-move');
        moveCell.onclick = () => moveToken(selectedPos, p);
      }
    });
  }

  function clearHighlights() {
    document.querySelectorAll('.cell').forEach(cell => {
      cell.classList.remove('selected', 'possible-move');
      cell.onclick = null;
    });
    if(selectedToken) {
      selectedToken.style.border = '';
      selectedToken = null;
      selectedPos = null;
    }
  }

  function moveToken(fromPos, toPos) {
    if(!selectedToken) return;
    // Block cells cannot be entered
    if(boardState[toPos] === 'block') return;

    // If king moves to star, player wins
    if(boardState[fromPos] === 'king' && boardState[toPos] === 'star') {
      alert('Congratulations! You Win!');
    }

    // Move token logically
    boardState[toPos] = boardState[fromPos];
    delete boardState[fromPos];

    clearHighlights();
    renderTokens();
  }

  function calculateMoves(pos, token) {
    const [r, c] = [rows.indexOf(pos[0]), cols.indexOf(pos[1])];
    const moves = [];

    function canMoveTo(row, col) {
      if(row<0 || row>=4 || col<0 || col>=4) return false;
      const p = rows[row] + cols[col];
      if(boardState[p] === 'block') return false;
      return true;
    }

    if(token === 'king') {
      for(let dr=-1; dr<=1; dr++) {
        for(let dc=-1; dc<=1; dc++) {
          if(dr===0 && dc===0) continue;
          if(canMoveTo(r+dr,c+dc)) moves.push(rows[r+dr]+cols[c+dc]);
        }
      }
    }
    else if(token === 'rook') {
      // Horizontal and vertical
      for(let i=r+1; i<4; i++) {
        if(!canMoveTo(i,c)) break;
        moves.push(rows[i]+cols[c]);
      }
      for(let i=r-1; i>=0; i--) {
        if(!canMoveTo(i,c)) break;
        moves.push(rows[i]+cols[c]);
      }
      for(let j=c+1; j<4; j++) {
        if(!canMoveTo(r,j)) break;
        moves.push(rows[r]+cols[j]);
      }
      for(let j=c-1; j>=0; j--) {
        if(!canMoveTo(r,j)) break;
        moves.push(rows[r]+cols[j]);
      }
    }
    else if(token === 'bishop') {
      // Diagonals
      for(let i=1; i<4; i++) {
        if(canMoveTo(r-i,c-i)) moves.push(rows[r-i]+cols[c-i]); else break;
      }
      for(let i=1; i<4; i++) {
        if(canMoveTo(r-i,c+i)) moves.push(rows[r-i]+cols[c+i]); else break;
      }
      for(let i=1; i<4; i++) {
        if(canMoveTo(r+i,c-i)) moves.push(rows[r+i]+cols[c-i]); else break;
      }
      for(let i=1; i<4; i++) {
        if(canMoveTo(r+i,c+i)) moves.push(rows[r+i]+cols[c+i]); else break;
      }
    }
    else if(token === 'knight') {
      // Knight moves
      const knightSteps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for(const [dr,dc] of knightSteps) {
        if(canMoveTo(r+dr,c+dc)) moves.push(rows[r+dr]+cols[c+dc]);
      }
    }

    return moves;
  }

  createBoard();
  loadBoardData();
</script>
</body>
</html>
