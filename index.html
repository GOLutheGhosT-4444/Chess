<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>4x4 Chess Game</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100vh; background: transparent;
    display: flex; justify-content: center; align-items: center;
  }
  #board {
    width: 320px;
    height: 320px;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 0;
    background: transparent;
    user-select: none;
    position: relative;
  }
  .cell {
    border: none;
    background: transparent;
    width: 100%;
    height: 100%;
    position: relative;
  }
  .token {
    position: absolute;
    width: 80%;
    height: 80%;
    top: 10%;
    left: 10%;
    cursor: pointer;
  }
  .token.fixed {
    cursor: default;
  }
</style>
</head>
<body>
<div id="board"></div>
<script>
  const TOKEN_IMAGES = {
    rook: 'rook.png',
    bishop: 'bishop.png',
    knight: 'knight.png',
    king: 'king.png',
    star: 'star.png',
    block: 'block.jpg'
  };
  const GITHUB_RAW_JSON_URL = 'https://raw.githubusercontent.com/GOLu496/Files/main/puzzle.json';

  const rows = ['A', 'B', 'C', 'D'];
  const cols = ['1', '2', '3', '4'];
  let boardState = {};  
  let fixedTokens = new Set();
  let selectedToken = null;
  let selectedPos = null;

  // Create board cells
  function createBoard() {
    document.getElementById('board').innerHTML = '';
    for (let r of rows) {
      for (let c of cols) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.pos = r + c;
        document.getElementById('board').appendChild(cell);
      }
    }
  }

  // Fetch JSON data from backend
  async function loadBoardData() {
    try {
      const res = await fetch(GITHUB_RAW_JSON_URL);
      const data = await res.json();
      setBoardState(data);
    } catch(e) {
      console.error('Fetching error:', e);
    }
  }

  function setBoardState(data) {
    boardState = {};
    fixedTokens.clear();
    document.querySelectorAll('.token').forEach(t => t.remove());
    for (let pos in data) {
      const token = data[pos];
      boardState[pos] = token;
      if (token === 'star' || token === 'block') {
        fixedTokens.add(pos);
      }
    }
    renderTokens();
  }

  function renderTokens() {
    for (let pos in boardState) {
      const token = boardState[pos];
      const cell = document.querySelector(`.cell[data-pos="${pos}"]`);
      const img = document.createElement('img');
      img.src = TOKEN_IMAGES[token] || 'unknown.png';
      img.className = 'token';
      if (fixedTokens.has(pos)) img.classList.add('fixed');
      img.dataset.pos = pos;
      img.dataset.token = token;
      cell.appendChild(img);

      if (!fixedTokens.has(pos)) {
        img.addEventListener('click', () => selectToken(img));
      }
    }
  }

  function selectToken(tokenElem) {
    if (selectedToken) selectedToken.style.border = '';
    selectedToken = tokenElem;
    selectedPos = tokenElem.dataset.pos;
    tokenElem.style.border = '2px solid #FFF';
    showPossibleMoves(selectedPos, tokenElem.dataset.token);
  }

  function showPossibleMoves(pos, token) {
    clearHighlights();
    const moves = calculateMoves(pos, token);
    moves.forEach(p => {
      const cell = document.querySelector(`.cell[data-pos="${p}"]`);
      if (cell && !fixedTokens.has(p)) {
        cell.style.outline = '2px solid yellow';
        cell.onclick = () => moveToken(pos, p);
      }
    });
  }

  function clearHighlights() {
    document.querySelectorAll('.cell').forEach(c => {
      c.style.outline = '';
      c.onclick = null;
    });
  }

  function moveToken(fromPos, toPos) {
    if (!selectedToken) return;
    // If move to star cell, and token is king, game won
    if (boardState[fromPos] === 'king' && boardState[toPos] === 'star') {
      alert('Congratulations! You Win!');
    }
    // Prevent move to block or star by other tokens (except king moving to star to win)
    if (boardState[toPos] === 'block') return;
    // Move token
    boardState[toPos] = boardState[fromPos];
    delete boardState[fromPos];
    selectedToken.style.border = '';
    selectedToken = null;
    selectedPos = null;
    clearHighlights();
    renderTokens();
  }

  function calculateMoves(pos, token) {
    // Allowed moves based on token type - simplified
    const [r, c] = [rows.indexOf(pos[0]), cols.indexOf(pos[1])];
    const moves = [];
    function addMove(row, col) {
      if (row >= 0 && row < 4 && col >= 0 && col < 4) {
        const p = rows[row] + cols[col];
        return p;
      }
      return null;
    }

    if (token === 'king') {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const p = addMove(r + dr, c + dc);
          if (p && !fixedTokens.has(p)) moves.push(p);
        }
      }
    } else if (token === 'rook') {
      // Horizontal & vertical
      for (let i = 0; i < 4; i++) {
        if (i !== r && !fixedTokens.has(rows[i] + cols[c])) moves.push(rows[i] + cols[c]);
        if (i !== c && !fixedTokens.has(rows[r] + cols[i])) moves.push(rows[r] + cols[i]);
      }
    } else if (token === 'bishop') {
      // Diagonal
      for (let i = 1; i < 4; i++) {
        // up-left
        if (addMove(r - i, c - i) && !fixedTokens.has(rows[r - i] + cols[c - i])) moves.push(rows[r - i] + cols[c - i]);
        // up-right
        if (addMove(r - i, c + i) && !fixedTokens.has(rows[r - i] + cols[c + i])) moves.push(rows[r - i] + cols[c + i]);
        // down-left
        if (addMove(r + i, c - i) && !fixedTokens.has(rows[r + i] + cols[c - i])) moves.push(rows[r + i] + cols[c - i]);
        // down-right
        if (addMove(r + i, c + i) && !fixedTokens.has(rows[r + i] + cols[c + i])) moves.push(rows[r + i] + cols[c + i]);
      }
    } else if (token === 'knight') {
      const knightMoves = [
        [-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]
      ];
      for (const [dr, dc] of knightMoves) {
        const p = addMove(r + dr, c + dc);
        if (p && !fixedTokens.has(p)) moves.push(p);
      }
    }
    return moves;
  }

  createBoard();
  loadBoardData();

  // Optional: refresh JSON periodically
  // setInterval(loadBoardData, 10000);
</script>
</body>
</html>
